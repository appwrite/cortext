/**
 * Change detection utility to distinguish between human and AI/LLM changes
 */

export interface ChangeSource {
  isHumanChange: boolean
  source: 'user' | 'ai' | 'system' | 'unknown'
  metadata?: {
    userId?: string
    messageId?: string
    revisionId?: string
    timestamp?: number
  }
}

export interface ArticleChange {
  articleId: string
  data: any
  source: ChangeSource
  version: number
}

/**
 * Detect if a change is from a human user based on various indicators
 */
export function detectChangeSource(
  change: any,
  context?: {
    userId?: string
    messageId?: string
    revisionId?: string
    isRevert?: boolean
    isInitialLoad?: boolean
  }
): ChangeSource {
  // System changes (initial load, reverts, etc.)
  if (context?.isInitialLoad || context?.isRevert) {
    return {
      isHumanChange: false,
      source: 'system',
      metadata: {
        userId: context.userId,
        revisionId: context.revisionId,
        timestamp: Date.now()
      }
    }
  }

  // AI/LLM changes (indicated by messageId or specific patterns)
  if (context?.messageId || isAIChange(change)) {
    return {
      isHumanChange: false,
      source: 'ai',
      metadata: {
        userId: context?.userId,
        messageId: context?.messageId,
        revisionId: context?.revisionId,
        timestamp: Date.now()
      }
    }
  }

  // User changes (direct user interaction)
  return {
    isHumanChange: true,
    source: 'user',
    metadata: {
      userId: context?.userId,
      timestamp: Date.now()
    }
  }
}

/**
 * Check if a change appears to be from AI/LLM
 */
function isAIChange(change: any): boolean {
  // Check for AI-specific patterns in the change data
  if (!change) return false

  // Check if change has AI-specific metadata
  if (change.metadata?.agentId || change.metadata?.aiGenerated) {
    return true
  }

  // Check for AI-specific content patterns
  if (change.data) {
    const dataStr = JSON.stringify(change.data).toLowerCase()
    
    // Common AI response patterns
    const aiPatterns = [
      'cortext',
      'ai-generated',
      'generated by',
      'assistant',
      'llm',
      'artificial intelligence'
    ]
    
    if (aiPatterns.some(pattern => dataStr.includes(pattern))) {
      return true
    }
  }

  return false
}

/**
 * Compare two article states and detect what changed
 */
export function detectArticleChanges(
  oldArticle: any,
  newArticle: any
): {
  hasChanges: boolean
  changes: string[]
  changedFields: string[]
} {
  const changes: string[] = []
  const changedFields: string[] = []


  if (!newArticle) {
    return { hasChanges: false, changes: [], changedFields: [] }
  }

  // If there's no old article, treat this as a new article with all fields as changes
  if (!oldArticle) {
    const fieldsToCompare = [
      'title', 'subtitle', 'trailer', 'status', 'live', 'pinned',
      'redirect', 'slug', 'authors', 'categories', 'images', 'body'
    ]
    
    fieldsToCompare.forEach(field => {
      const newValue = newArticle[field]
      if (newValue !== null && newValue !== undefined && newValue !== '') {
        changedFields.push(field)
        changes.push(`${field} set`)
      }
    })
    
    return { 
      hasChanges: changedFields.length > 0, 
      changes, 
      changedFields 
    }
  }

  // Compare basic fields
  const fieldsToCompare = [
    'title', 'subtitle', 'trailer', 'status', 'live', 'pinned',
    'redirect', 'slug', 'authors', 'categories', 'images', 'body'
  ]

  fieldsToCompare.forEach(field => {
    const oldValue = oldArticle[field]
    const newValue = newArticle[field]
    
    if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
      changedFields.push(field)
      
      if (field === 'body') {
        changes.push('Content sections updated')
      } else if (field === 'authors') {
        changes.push('Authors updated')
      } else if (field === 'categories') {
        changes.push('Categories updated')
      } else {
        changes.push(`${field} updated`)
      }
    }
  })

  return {
    hasChanges: changes.length > 0,
    changes,
    changedFields
  }
}

/**
 * Create a change object for storage
 */
export function createChangeObject(
  articleId: string,
  data: any,
  source: ChangeSource,
  version: number = 1
): ArticleChange {
  return {
    articleId,
    data,
    source,
    version
  }
}

